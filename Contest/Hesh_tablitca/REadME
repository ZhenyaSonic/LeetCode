Что такое хеш-таблица?
В этом уроке ты
Узнаешь, зачем нужна хеш-таблица.
Научишься использовать её в своём языке программирования.
Поймёшь, как часто хеш-таблица встречается на собеседованиях.
Разберёшься, какие операции доступны в хеш-таблице и насколько они быстрые.
Как часто хеш-таблица встречается на собеседованиях

Каждый третий разработчик на собеседовании сталкивается с задачей, где нужна хеш-таблица.

Такой интерес к ней вызван широкой областью применения и эффективностью при решении задач поиска, вставки и удаления.

Кроме практических задач, нередко можно услышать вопрос: «Расскажи, как хеш-таблица работает внутри». Чуть позже мы обязательно вернёмся к этому важному вопросу.

Хеш-таблица в твоём языке программирования
Почти в каждом языке программирования есть встроенные хеш-таблицы. Их объединяет высокая скорость операций, но синтаксис и детали реализации могут отличаться.

Чтобы не растеряться на собеседовании, давай разберём основные операции в твоём языке.

hash_table = dict()

# Вставка/обновление
hash_table[1] = 3

# Поиск
val = hash_table[1]
print(val)

# Удаление ключа "1"
del hash_table[1]

# Узнать размер
print(len(hash_table))
Главное, что нужно знать о хеш-таблице

Поиск в хеш-таблице работает быстро, как и вставка, удаление и получение значений по ключу.

Однако в редких случаях сложность может стать O(n) из-за особенностей реализации. Почему это происходит, разберём позже. Важно запомнить, что в среднем все операции выполняются за O(1):


Главный вывод: все операции хеш-таблицы в среднем работают за O(1), и именно так их следует оценивать при анализе сложности кода.

Представь, что каждая 100 000-я операция занимает O(n), а остальные 99 999 выполняются за O(1). Это примерная модель, но смысл передаёт хорошо.

Пример задачи с собеседования

Представь, что ты проходишь собеседование. На выполнение первой задачи у тебя есть примерно 20 минут. Вперёд!

Условие
 Дан массив целых чисел nums и число target. Нужно вернуть индексы двух чисел из массива nums, которые в сумме дают target. Гарантируется, что есть только один ответ, и индексы должны быть в порядке возрастания.  

Пример
Ввод: nums = [1,4,3,-6,2,5], target = -1
Вывод: [3,5]
Объяснение: -6 + 5 = -1. "-6" имеет индекс 3, а "5" индекс 5
В чем сложность задачи
Если ты только начинаешь программировать и не решал задач на хеш-таблицы, твоё первое решение может быть неоптимальным:

# Время:  O(n * n), где n — длина массива nums
# Память: O(1)
def two_sum(nums: List[int], target: int) -> List[int]:
    # Перебираем все возможные пары чисел
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
Здесь идёт полный перебор всех пар чисел, что занимает O(n²) времени. Это слишком долго для данной задачи, поэтому интервьюер попросит тебя найти более оптимальное решение.  

Оптимальное решение
Для оптимального решения используем хеш-таблицу.

from typing import List

# Время:  O(n), где n — длина массива nums
# Память: O(n)
def two_sum(nums: List[int], target: int) -> List[int]:
    # Ключ — число, значение — индекс, на котором встретили число
    used_nums = {}

    for idx, second_num in enumerate(nums):
        # first_num — число, которое должно было встретиться ранее
        # чтобы second_num + first_num = target
        first_num = target - second_num
        # Если first_num уже встречали, возвращаем их индексы
        if first_num in used_nums:
            return [used_nums[first_num], idx]
        used_nums[second_num] = idx
    return []

Идея в том, чтобы в качестве ключа использовать элемент массива, а в качестве значения — его индекс. Далее надо перебрать все числа в массиве, предполагая, что текущее число — одно из искомых. Второе число определяем как first_num = target - second_num. Если first_num уже есть в хеш-таблице, возвращаем результат. Иначе добавляем текущее число в хеш-таблицу.  

Так хеш-таблица хранит числа, которые мы уже прошли, и позволяет быстро проверить, встречали ли мы ранее число, которое в сумме с текущим даёт target.  

Зачем нужны массивы, когда есть хеш-таблица

Может показаться, что хеш-таблица идеальна, но у каждой структуры данных свои преимущества.

Например, если нужно часто искать студента по имени, подойдёт хеш-таблица. Но если нужно один раз найти элемент, проще воспользоваться массивом. Построение хеш-таблицы займёт больше времени, чем обычный проход по массиву.

Заключение
На этой лекции мы познакомились с хеш-таблицами, разобрались с принципами их работы и решили задачу с их использованием. Приступай к следующему уроку, чтобы уверенно себя чувствовать на собеседовании и в работе!

ПРОДОЛЖЕНИЕ:

Что такое множество?
Что такое множество?
В этом уроке ты
Узнаешь, что такое множество.
Научишься использовать его в своём языке программирования.
Решишь задачу с использованием множества.
Знакомство с множеством

Множество (хеш-сет) — это одна из ключевых структур данных, которая используется для хранения уникальных элементов без соблюдения их порядка.

Как ты узнал из предыдущей лекции, хеш-таблица хранит пары "ключ — значение", тогда как множество содержит только уникальные ключи без значений. Это позволяет экономить память в задачах, где нужно хранить только ключи.

Множество в твоём языке программирования

hash_set = set()

# Вставка
hash_set.add(1)

# Проверка наличия
print(1 in hash_set)  # True

# Удаление
hash_set.remove(1)  # Если элемента нет, вызывает KeyError
# hash_set.discard(1)  # Удаляет без ошибки, если элемента нет

# Узнать размер
print(len(hash_set))
Задача на поиск повторяющихся элементов

Подобная задача может встретиться не только на собеседовании, но и в реальной работе. Каждый разработчик должен знать, как быстро и эффективно находить совпадающие элементы. Давай разберемся!

Условие
Дан массив целых чисел nums. Надо вернуть true, если массив содержит повторяющиеся элементы и false, если нет.  

Пример 1
Ввод: nums = [1,3,5,2,5]
Вывод: true
Объяснение: элемент 5 встречается два раза
Пример 2
Ввод: nums = [3,5,7,9]
Вывод: false
Объяснение: все элементы уникальны
Решение с использованием хеш-таблицы
При решении с использованием хеш-таблицы значение элемента из массива используется в качестве ключа, а в качестве значения записывается true, как индикатор того, что данный элемент ранее встречался.  
#Время: O(n), где n — размер входного массива.
#Память: O(n), где n — размер входного массива.
def contains_duplicate(nums: List[int]) -> bool:
    # Создаем хеш-таблицу
    used = dict()
    for num in nums:
        # Проверяем наличие в хеш-таблице
        if num in used:
            return True
        # Добавляем элемент в хеш-таблицу
        used[num] = True
    return False
Такое решение абсолютно верное, но расходует чуть больше памяти, потому что нам надо хранить и ключ, и значение. Поэтому в таких случаях лучше использовать множество.

Решение с использованием множества
#Время: O(n), где n — размер входного массива.
#Память: O(n), где n — размер входного массива.
def contains_duplicate(nums: List[int]) -> bool:
    # Создаем множество
    used = set()
    for num in nums:
        # Проверяем наличие в множестве
        if num in used:
            return True
        # Добавляем элемент в множество
        used.add(num)
    return False
Какое решение лучше?
Оба решения являются верными, но использование множества, хранящего только ключи, является более предпочтительным, так как это позволяет экономить память за счет исключения хранения значений.

Заключение
На этой лекции мы познакомились с множеством, изучили принцип его работы и решили задачу. Теперь приступай к практической части, чтобы закрепить свои знания!